{{- /* 
	Shortcode: glossary
	Description: Renders a definition list from a CSV file with an alphabetical index and a search box for filtering.
	Parameters:
	  - path (string): The path to the CSV file.
	  - delimiter (string): Optional. Defaults to a comma.
	  - outputFormat (string): Optional. Either "md" for Markdown (default) or "html" for HTML output.
	  - hasHeaderRow (bool): Optional. Defaults to true.
*/ -}}

{{- $path := .Get "path" -}}
{{- if not $path -}}
	{{- errorf "The glossary shortcode requires a path parameter." -}}
{{- end -}}

{{- $delimiter := or (.Get "delimiter") "," -}}
{{- $outputFormat := or (.Get "outputFormat") "md" -}}
{{- $hasHeaderRow := true -}}
{{- if isset .Params "hasHeaderRow" -}}
	{{- if in (slice false "false") (.Get "hasHeaderRow") -}}
		{{- $hasHeaderRow = false -}}
	{{- end -}}
{{- end -}}

{{- /* Resolve the CSV resource */ -}}
{{- $r := "" -}}
{{- $u := urls.Parse $path -}}
{{- if $u.IsAbs -}}
	{{- with try (resources.GetRemote $u.String) -}}
		{{- with .Err -}}
			{{- errorf "%s" . -}}
		{{- else with .Value -}}
			{{- $r = . -}}
		{{- else -}}
			{{- errorf "The glossary shortcode was unable to get %s" $u.String -}}
		{{- end -}}
	{{- end -}}
{{- else -}}
	{{- with .Page.Resources.Get (strings.TrimPrefix "./" $u.Path) -}}
		{{- $r = . -}}
	{{- else -}}
		{{- with (and (ne .Page.BundleType "leaf") (.Page.CurrentSection.Resources.Get (strings.TrimPrefix "./" $u.Path))) -}}
			{{- $r = . -}}
		{{- else -}}
			{{- with resources.Get $u.Path -}}
				{{- $r = . -}}
			{{- else -}}
				{{- errorf "The glossary shortcode was unable to get %s" $u.String -}}
			{{- end -}}
		{{- end -}}
	{{- end -}}
{{- end -}}

{{- $data := unmarshal (dict "delimiter" $delimiter) $r -}}
{{- if not $data -}}
	{{- errorf "No data found in CSV file: %s" $path -}}
{{- end -}}

{{- /* Process CSV: if a header row exists, use it to build maps for each row */ -}}
{{- if $hasHeaderRow -}}
	{{- $rawHeader := index $data 0 -}}
	{{- $header := slice -}}
	{{- range $rawHeader -}}
		{{- $header = $header | append (trim . " ") -}}
	{{- end -}}
	{{- .Scratch.Set "header" $header -}}

	{{- $rowsMap := slice -}}
	{{- range $data | after 1 -}}
		{{- $rowMap := dict -}}
		{{- range $i, $cell := . -}}
			{{- $key := index $header $i -}}
			{{- $rowMap = merge $rowMap (dict $key $cell) -}}
		{{- end -}}
		{{- $rowsMap = $rowsMap | append $rowMap -}}
	{{- end -}}
	{{- .Scratch.Set "rowsMap" $rowsMap -}}
{{- else -}}
	{{- errorf "The glossary shortcode requires a header row in the CSV file." -}}
{{- end -}}

{{- $rowsMap := .Scratch.Get "rowsMap" -}}

{{- if eq $outputFormat "html" -}}
	{{- $html := slice -}}

	{{- /* Bootstrap 4 formatted search box */ -}}
	{{- $html = $html | append "<div class=\"form-group\"><input type=\"text\" class=\"form-control\" id=\"glossarySearch\" placeholder=\"Search definitions...\"></div>" -}}

	{{- /* Build the alphabetical index */ -}}
	{{- $letters := slice "A" "B" "C" "D" "E" "F" "G" "H" "I" "J" "K" "L" "M" "N" "O" "P" "Q" "R" "S" "T" "U" "V" "W" "X" "Y" "Z" -}}
	{{- $html = $html | append "<div class=\"glossary-index\">" -}}
	{{- range $letters -}}
		{{- $html = $html | append (printf "<a href=\"#\" class=\"glossary-index-letter\" data-letter=\"%s\">%s</a> | " . .) -}}
	{{- end -}}
	{{- $html = $html | append "<a href=\"#\" class=\"glossary-index-letter\" data-letter=\"all\"><strong> All</strong></a>" -}}
	{{- $html = $html | append "</div><br>" -}}

	{{- /* Build the glossary definition list with data-letter attributes */ -}}
	{{- $html = $html | append "<dl class=\"glossary\">" -}}
	{{- range $row := $rowsMap -}}
		{{- $concept := index $row "Concept" -}}
		{{- $definition := index $row "Definition" -}}
		{{- $source1 := index $row "Source 1" -}}
		{{- $source2 := index $row "Source 2" -}}
		{{- $description := index $row "Description" -}}
		{{- $example := index $row "Example" -}}
		{{- $firstLetter := upper (substr $concept 0 1) -}}

		{{- /* Parse links in the source fields */ -}}
		{{- $source1Parsed := replaceRE "(https?://[^[:space:]]+)" "<a href=\"$1\">$1</a>" $source1 -}}
		{{- $source2Parsed := replaceRE "(https?://[^[:space:]]+)" "<a href=\"$1\">$1</a>" $source2 -}}

		{{- /* Output term and definition, each tagged with the first letter */ -}}
		{{- $html = $html | append (printf "<dt data-letter=\"%s\">%s</dt>" $firstLetter $concept) -}}
		{{- $html = $html | append (printf "<dd data-letter=\"%s\"><p><strong>Definition:</strong> %s</p>" $firstLetter $definition) -}}
		{{- if or $source1Parsed $source2Parsed -}}
			{{- $sources := slice -}}
			{{- if $source1Parsed -}}
				{{- $sources = $sources | append $source1Parsed -}}
			{{- end -}}
			{{- if $source2Parsed -}}
				{{- $sources = $sources | append $source2Parsed -}}
			{{- end -}}
			{{- $html = $html | append (printf "<p><strong>Sources:</strong> %s</p>" (delimit $sources ", ")) -}}
		{{- end -}}
		{{- $html = $html | append (printf "<p><strong>Description:</strong> %s</p>" $description) -}}
		{{- $html = $html | append (printf "<p><strong>Example:</strong> %s</p></dd>" $example) -}}
	{{- end -}}
	{{- $html = $html | append "</dl>" -}}

	{{- /* Add inline JavaScript for filtering by alphabetical index and search box */ -}}
	{{- $script := `
<script>
document.addEventListener("DOMContentLoaded", function() {
  const indexLinks = document.querySelectorAll(".glossary-index-letter");
  const searchBox = document.getElementById("glossarySearch");
  const items = document.querySelectorAll(".glossary dt, .glossary dd");
  // On load, show all items
  items.forEach(item => item.style.display = "");
  // Alphabetical filtering
  indexLinks.forEach(link => {
    link.addEventListener("click", function(e) {
      e.preventDefault();
      // Clear search box when using the index
      searchBox.value = "";
      const letter = this.getAttribute("data-letter");
      indexLinks.forEach(l => l.classList.remove("active"));
      this.classList.add("active");
      items.forEach(item => {
        if(letter === "all" || item.getAttribute("data-letter") === letter) {
          item.style.display = "";
        } else {
          item.style.display = "none";
        }
      });
    });
  });
  // Search filtering: show full list when search is empty
  searchBox.addEventListener("input", function() {
    const searchVal = this.value.toLowerCase();
    indexLinks.forEach(l => l.classList.remove("active"));
    if(searchVal.length > 0) {
      items.forEach(item => {
        if(item.textContent.toLowerCase().indexOf(searchVal) > -1) {
          item.style.display = "";
        } else {
          item.style.display = "none";
        }
      });
    } else {
      // If search is cleared, show all items.
      items.forEach(item => item.style.display = "");
    }
  });
});
</script>
` -}}
	{{- $html = $html | append $script -}}

	{{- .Scratch.Set "htmlGlossary" (delimit $html "") -}}
	{{- markdownify (.Scratch.Get "htmlGlossary") -}}
{{- else -}}
	{{- /* Markdown output remains unchanged; interactive filtering requires HTML/JS */ -}}
	{{- $md := slice -}}
	{{- range $row := $rowsMap -}}
		{{- $concept := index $row "Concept" -}}
		{{- $definition := index $row "Definition" -}}
		{{- $source1 := index $row "Source 1" -}}
		{{- $source2 := index $row "Source 2" -}}
		{{- $description := index $row "Description" -}}
		{{- $example := index $row "Example" -}}

		{{- /* Parse links: convert URLs into Markdown links */ -}}
		{{- $source1Parsed := replaceRE "(https?://[^[:space:]]+)" "[$1]($1)" $source1 -}}
		{{- $source2Parsed := replaceRE "(https?://[^[:space:]]+)" "[$1]($1)" $source2 -}}

		{{- $md = $md | append $concept -}}
		{{- $line := printf ": **Definition:** %s" $definition -}}
		{{- $md = $md | append $line -}}
		{{- if or $source1Parsed $source2Parsed -}}
			{{- $sources := slice -}}
			{{- if $source1Parsed -}}
				{{- $sources = $sources | append $source1Parsed -}}
			{{- end -}}
			{{- if $source2Parsed -}}
				{{- $sources = $sources | append $source2Parsed -}}
			{{- end -}}
			{{- $line = printf ": **Sources:** %s" (delimit $sources ", ") -}}
			{{- $md = $md | append $line -}}
		{{- end -}}
		{{- $line = printf ": **Description:** %s" $description -}}
		{{- $md = $md | append $line -}}
		{{- $line = printf ": **Example:** %s" $example -}}
		{{- $md = $md | append $line -}}
		{{- $md = $md | append "" -}}  {{/* blank line between entries */}}
	{{- end -}}
	{{- markdownify (delimit $md "\n") -}}
{{- end -}}